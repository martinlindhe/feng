# STATUS: 70% (all test files parse fully)

# - MID: PLTE chunk want custom type "rgb"
# - MID: decode "vpAg" chunk (need docs)
# - MID: decode utf8 text in iTXt
# - LOW: crc32 data type

references:
  - https://en.wikipedia.org/wiki/Portable_Network_Graphics
  - http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
  - https://www.sweetscape.com/010editor/repository/files/PNG.bt
  - https://github.com/HexFiend/HexFiend/blob/master/templates/Images/PNG.tcl
  - https://github.com/martinlindhe/formats/blob/master/parse/image/img_png.go

kind: image
extensions: [.png]
mime: image/png
endian: big

constants:
  ascii[4] IDAT: c'IDAT'
  ascii[4] PLTE: c'PLTE'
  ascii[4] IEND: c'IEND'
  ascii[4] sBIT: c'sBIT'
  ascii[4] sRGB: c'sRGB'
  ascii[4] pHYs: c'pHYs'
  ascii[4] tEXt: c'tEXt'
  ascii[4] zTXt: c'zTXt'
  ascii[4] iTXt: c'iTXt'
  ascii[4] iCCP: c'iCCP'
  ascii[4] tIME: c'tIME'
  ascii[4] bKGD: c'bKGD'
  ascii[4] cHRM: c'cHRM'
  ascii[4] gAMA: c'gAMA'

  ascii[4] iDOT: c'iDOT'                  # non-registered chunk used by Apple

types:
  rgb:
    u8 Red: ??
    u8 Green: ??
    u8 Blue: ??

structs:
  header:
    u8[8] Signature: 89 c'PNG' 0d 0a 1a 0a

  ihdr:
    u32 Length: ??
    ascii[4] Type: c'IHDR'
    u32 Width: ??
    u32 Height: ??
    u8 Bit depth:
      eq 01: 1 bpp
      eq 02: 2 bpp
      eq 04: 4 bpp
      eq 08: 8 bpp
      eq 10: 16 bpp
    u8 Color type:
      eq 00: grayscale
      eq 02: RGB
      eq 03: palette
      eq 04: grayscale+alpha
      eq 06: RGBA
    u8 Compression method:
      eq 00: deflate                        # NOTE: the concatenation of the contents of all the IDAT chunks makes up a zlib datastream
    u8 Filter method:
      eq 00: none+sub+up+average+paeth
    u8 Interlace method:
      eq 00: no interlace
      eq 01: Adam7 interlace
    u32 Checksum: ??                        # XXX crc32 type

  chunk:
    u32 Length: ??                          # length of chunk data (excluding Length and Type fields)
    ascii[4] Type: ??

    if self.Type in (IDAT):
      u8[self.Length] Image data: ??

    if self.Type in (PLTE):
      #rgb[self.Length / 3] Palette: ??      # XXX chunk Length 768 = 256 palette values (R, G, B)   need to use custom type "rgb"
      u8[self.Length] Palette: ??

    if self.Type in (sBIT):
      if IHDR.Color type in (0): # grayscale
        u8 Significant bits grayscale: ??
      if IHDR.Color type in (2,3): # RGB or palette
        u8 Significant bits red: ??
        u8 Significant bits green: ??
        u8 Significant bits blue: ??
      if IHDR.Color type in (4):  # grayscale+alpha
        u8 Significant bits grayscale: ??
        u8 Significant bits alpha: ??
      if IHDR.Color type in (6):  # RGBA
        u8 Significant bits red: ??
        u8 Significant bits green: ??
        u8 Significant bits blue: ??
        u8 Significant bits alpha: ??

    if self.Type in (sRGB):
      u8 Rendering intent:
        eq 00: Perceptual
        eq 01: Relative colorimetric
        eq 02: Saturation
        eq 03: Absolute colorimetric

    if self.Type in (pHYs):
      u32 Pixels per unit, X axis: ??
      u32 Pixels per unit, Y axis: ??
      u8 Unit specifier:
        eq 00: Unknown
        eq 01: Meter

    if self.Type in (tEXt):
      asciiz Keyword: ??
      ascii[self.Length - len("self.Keyword")] Text: ??

    if self.Type in (zTXt):
      asciiz Keyword: ??
      u8 Compression method:
        eq 00: Deflate
        default: invalid
      u8[self.Length - (self.offset - offset("self.Keyword"))] Compressed text: ??            # XXX mark as deflate for decompression

    if self.Type in (iTXt):
      asciiz Keyword: ??
      u8 Compression flag:
        eq 00: Uncompressed
        eq 01: Compressed
      u8 Compression method:
        eq 00: Deflate
        default: invalid
      asciiz Language tag: ??
      asciiz Translated keyword: ??
      ascii[self.Length - (self.offset - offset("self.Keyword"))] Text: ?? # XXX is UTF-8 encoded, not ascii !!!

    if self.Type in (iCCP):
      asciiz ProfileName: ??
      u8 Compression method:
        eq 00: Deflate
        default: invalid
      u8[self.Length - (self.offset - offset("self.ProfileName"))] Compressed profile: ??   # XXX mark as deflate for decompression

    if self.Type in (tIME):
      # time in UTC
      u16 Year: ??
      u8 Month: ??
      u8 Day: ??
      u8 Hour: ??
      u8 Minute: ??
      u8 Second: ??

    if self.Type in (bKGD):
      if IHDR.Color type in(3):             # indexed
        u8 Palette index: ??

      if IHDR.Color type in (0,4):          # grayscale or grayscale+alpha
        u16 Gray: ??

      if IHDR.Color type in (2,6):          # RGB or RGBA
        u16 Red: ??
        u16 Green: ??
        u16 Blue: ??

    if self.Type in (cHRM):
      u32 White Point x: ??
      u32 White Point y: ??
      u32 Red x: ??
      u32 Red y: ??
      u32 Green x: ??
      u32 Green y: ??
      u32 Blue x: ??
      u32 Blue y: ??

    if self.Type in (gAMA):
      u32 Gamma: ??

    if self.Type in (iDOT):
      # NOTE: based on guesses from https://www.hackerfactor.com/blog/index.php?/archives/895-Connecting-the-iDOTs.html
      u32 Height divisor: ??
      u32 Unknown: ??                       # always 0 ?
      u32 Divided height: ??
      u32 Unknown: ??                       # always 0x40 ?
      u32 First half height: ??
      u32 Second half height: ??
      u32 IDAT restart offset: ??

    # UNKNOWN CHUNK TYPE
    if self.Type notin (IDAT, PLTE, sBIT, sRGB, pHYs, tEXt, zTXt, iTXt, iCCP, tIME, bKGD, cHRM, gAMA, iDOT):
      u8[self.Length] Chunk data: ??

    #crc32[Type_IHDR.offset:self.offset] Checksum: ??   # XXX crc32 in big-endian of chunk minus Length and CRC field
    u32 Checksum: ??                        # XXX crc32 type

layout:
  - header Header
  - ihdr IHDR                               # a valid PNG must start with an IHDR chunk (FIXME: this breaks if IHDR is missing and another chunk is matched)
  - chunk[] Chunk                           # unknown amount of chunks until end of file
