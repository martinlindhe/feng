# STATUS: 30%

# - MAX: figure out how to decode image data stream (between SOS and EOI markers)
#     - need a way to specify unknown length of data until marker bytes is seen
#
# - HI: file is a stream of packets with different signature. parse until EOF
# - MID: use custom types

references:
  - https://en.wikipedia.org/wiki/JPEG
  - https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format
  - https://www.sweetscape.com/010editor/repository/files/JPG.bt
  - https://github.com/HexFiend/HexFiend/blob/master/templates/Images/JPEG.tcl
  - https://github.com/martinlindhe/formats/blob/master/parse/image/img_jpeg.go

kind: image
extensions: [.jpg, .jpeg]
mime: image/jpeg
endian: big

magic:
  - offset: 0000
    match: ff d8

types:
  # XXX MAKE USE OF
  COMPS:
    u8 compId: ??
    u8 Flag:
      bit b1111_0000: Horizontal
      bit b0000_1111: Vertical
    u8 compNr: ??

  COMPSOS:
    u8 compId: ??
    u8 Flag:
      bit b1111_0000: DC
      bit b0000_1111: AC

structs:
  header:
    u8[2] SOI marker: ff d8

  segment:
    u16 Signature:
      eq ffe0: M_APP0
      eq ffe1: M_APP1
      eq fffe: M_COMM
      eq ffdb: M_DQT
      eq ffc4: M_DHT
      eq ffda: M_SOS
      eq ffc0: M_SOF0
      eq ffc2: M_SOF2
      eq ffd9: M_EOI

    label: self.Signature

    u16 Length: ??  # length of segment excluding signature

    if self.Signature == M_APP0:
      u32 Identifier: # XXX TODO: allow pattern matching on ascii[4]
        eq c'JFIF': JFIF_APP0
        eq c'JFXX': JFXX_APP0
        default: invalid
      u8 Reserved: "00"

      if ! self.Identifier in {JFIF_APP0, JFXX_APP0}:
        u8[Length] Unknown data: ?? # XXX verify this Length

      if self.Identifier == JFIF_APP0:
        u8 Major version: ??
        u8 Minor version: ??
        u8 Density units:
          eq 00: No units
          eq 01: Pixels per inch
          eq 02: Pixels per centimeter
        u16 Xdensity: ??
        u16 Ydensity: ??
        u8 Xthumbnail: ??
        u8 Ythumbnail: ??
        #if Xthumbnail != 0 && Ythumbnail != 0: # XXX ?! if form ...
        #  rgb8[Xthumbnail * Ythumbnail * 3] Thumbnail data: ?? # XXX 8 bit per channel rgb: R, G, B bytes

      if self.Identifier == JFXX_APP0:
        u8 Thumbnail format:
          eq 10: JPEG format
          eq 11: 1bpp palettized format
          eq 13: 3bpp RGB format
        u8[10] Thumbnail data: ?? # XXX size depends on Thumbnail format, see tagApp0 in https://www.sweetscape.com/010editor/repository/files/JPG.bt

    if self.Signature == M_APP1:
      ascii[6] EXIF: c'Exif' 00 00 # XXX
      ascii[2] Align: ??  # XXX marks endianness. FIXME map big & little values + invalidate rest
      if self.Align == "II":  # XXX execution bug right now here !!!!
        endian: little
      u16 tagMark: ??
      u32 offsetFirstIFD: ?? # XXX
      # XXX WHAT FOLLOWS IS A LIST OF SECTIONS ...
      # XXX TODO FINISH

    if self.Signature == M_COMM:
      ascii[self.Length - 2] Comment: ??

    if self.Signature == M_DQT:
      u8 QuanFlag:
        bit b1111_0000: Pq
        bit b0000_1111: Tq
      #if self.QuanFlag.Pq == 0:  # XXX does not seem to eval ?!?!?!   because QuanFlag fields was never mapped up, because eval code is not fully recursive
      u8[64] qTable: ??
      #if !(self.QuanFlag.Pq == 0):    # XXX does not seem to eval ?!?!?!
      #  u16[64] qTable: ??

    if self.Signature == M_DHT:
      u8 htInfo: ??
      u8[16] htLength: ??
      u8[self.Length - 2 - 1 - 16] HTV: ??

    if self.Signature == M_SOS:
      u8 nr_comp: ??
      u8[2 * self.nr_comp] COMPSOS data: ?? # XXX nr_comp number of COMPSOS structs. XXX make COMPSOS a types
      u8 Ss: ??
      u8 Se: ??
      u8 Flag:
        bit b1111_0000: Ah
        bit b0000_1111: Al

      # maps all bytes until M_EOI marker is seen into scanData
      until: u8 scanData ff d9

    if self.Signature == M_SOF0:
      u8 Precision: ??
      u16 Image height: ??
      u16 Image width: ??
      u8 nr_comp: ??
      u8[3 * self.nr_comp] COMPS data: ?? # XXX nr_comp number of COMPS structs. XXX make COMPS a types

    if self.Signature == M_SOF2:
      u8 Precision: ??
      u16 Image height: ??
      u16 Image width: ??
      u8 nr_comp: ??
      u8[3 * self.nr_comp] COMPS data: ?? # XXX nr_comp number of COMPS structs. XXX make COMPS a types

layout:
  - header Header
  - segment[] Segment
