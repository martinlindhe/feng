# STATUS: 10%

# HI: rewrite for slice parsing! (need custom types)

# TODO: need to get absolute value of hive_bin_header.Cell size. we must evaluate all expressions and add an abs() function
# - LOW: calculate checksums

references:
  - https://github.com/libyal/libregf/blob/main/documentation/Windows%20NT%20Registry%20File%20(REGF)%20format.asciidoc
  - https://github.com/msuhanov/regf/blob/master/Windows%20registry%20file%20format%20specification.md
  - https://www.sweetscape.com/010editor/repository/files/RegistryHive.bt

kind: system
name: Windows NT Registry File
extensions: [.dat] # has no standard extension
endian: little

constants:
  ascii[2] SIG_NK: c'nk'   # Key Node
  ascii[2] SIG_SK: c'sk'   # Key Security
  ascii[2] SIG_VK: c'vk'   # Key Value
  ascii[2] SIG_LF: c'lf'   # Fast Leaf

types:
  # XXX impl!!!
  version:
    u32 Major: ??
    u32 Minor: ??

structs:
  base_block:
    ascii[4] Signature: c'regf'
    u32 Primary seq number: ??
    u32 Secondary seq number: ??
    filetime Timestamp: ??
    # version Version: ??   # XXX impl
    u32 Major version: ??
    u32 Minor version: ??
    u32 File type:
      eq 0000_0000: Primary file
    u32 File format:
      eq 0000_0001: Direct memory load
    u32 Root cell offset: ??
    u32 Hive bins data size: ??
    u32 Clustering factor: ??
    utf16[32] File name: ??
    u8[396] Reserved: ??
    u32 Checksum: ??          # xor-32 of the previous 508 bytes
    u8[3576] Reserved: ??
    u32 Boot type: ??
    u32 Boot recover: ??
  
  hive_bin:
    ascii[4] Signature: c'hbin'
    u32 Offset: ??   # XXX relative offset to after header. XXX make use of
    u32 Size: ??
    u8[8] Reserved: ??
    filetime Timestamp: ??
    u32 Spare: ??


  
  nk_cell:
    i32 CellSize: ??   # XXX:  the size is positive if a cell is unallocated or negative if a cell is allocated (use abs() calculations)
    ascii[2] Cell signature: ??

    # KEY NODE
    if self.Cell signature in (SIG_NK):
      u16 Flags:
        bit 00_01: KEY_VOLATILE
        bit 00_02: KEY_HIVE_EXIT
        bit 00_04: KEY_HIVE_ENTRY
        bit 00_08: KEY_NO_DELETE
        bit 00_10: KEY_SYM_LINK
        bit 00_20: KEY_COMP_NAME
        bit 00_40: KEY_PREDEF_HANDLE
        bit 00_80: VirtualSource
        bit 01_00: VirtualTarget
        bit 02_00: VirtualStore

      filetime Timestamp: ??
      u32 Access bits:
        bit 0000_0001: was accessed before registry was initialized
        bit 0000_0002: was accessed after registry was initialized

      u32 Parent cell offset: ??
      i32 Number of subkeys: ??
      i32 Number of volatile subkeys: ??
      i32 Subkeys list offset: ??
      i32 Volatile subkeys list offset: ??
      i32 Number of key values: ??
      i32 Key values list offset: ??
      i32 Key security offset: ??
      i32 Class name offset: ??
      i32 Largest subkey name length: ??
      i32 Largest subkey class name length: ??
      i32 Largest value name length: ??
      i32 Largest value data size: ??
      i32 WorkVar: ??
      u16 KeyLength: ??
      u16 Class name length: ??
      ascii[self.KeyLength] Key: ??
      u8[abs(self.CellSize) - 0x50 - self.KeyLength] Padding: ??

  sk_cell:
    i32 CellSize: ??   # XXX:  the size is positive if a cell is unallocated or negative if a cell is allocated (use abs() calculations)
    ascii[2] Cell signature: ??

    if self.Cell signature in (SIG_SK):
      u16 Reserved: ??
      i32 Flink: ??
      i32 Blink: ??
      i32 Reference count: ??
      i32 DescriptorLength: ??
      u8[self.DescriptorLength] Descriptor: ??      # XXX decode DESCRIPTOR ... see https://www.sweetscape.com/010editor/repository/files/RegistryHive.bt
      u8[abs(self.CellSize) - 0x18 - self.DescriptorLength] Padding: ??

  vk_cell:
    i32 CellSize: ??   # XXX:  the size is positive if a cell is unallocated or negative if a cell is allocated (use abs() calculations)
    ascii[2] Cell signature: ??

    if self.Cell signature in (SIG_VK):
      u16 Name length: ??
      i32 Data length: ??
      i32 Data offset: ??
      i32 Type: ??
      u16 Flags: ??
      u16 Spare: ??

  lf_list:
    i32 CellSize: ??   # XXX:  the size is positive if a cell is unallocated or negative if a cell is allocated (use abs() calculations)
    ascii[2] Cell signature: ??

    if self.Cell signature in (SIG_LF):
      i16 NumberOfOffsets: ??
      u8[8 * self.NumberOfOffsets] Offset: ?? # XXX decode "int offset, char[4] HASH" (8 bytes per entry)

layout:
  - base_block FILE HEADER
  - hive_bin HBINRECORD
  # XXX listed as winxp SAM atm...
  - nk_cell CELL_NK0
  - sk_cell CELL_SK0
  - nk_cell CELL_NK1
  - sk_cell CELL_SK1
  - lf_list LIST_LF0
  - nk_cell CELL_NK2
  - vk_cell CELL_VK0

  #- hive_bin[] HBINRECORD     # XXX slice